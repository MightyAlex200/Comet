'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

// Helper anchor functions

function anchor(anchorType, anchorText) {
  return call('anchors', 'anchor', {
    anchorType: anchorType,
    anchorText: anchorText
  }).replace(/"/g, '');
}

function anchorExists(anchorType, anchorText) {
  return call('anchors', 'exists', {
    anchorType: anchorType,
    anchorText: anchorText
  });
}

// Helper timemachine functions

function markUpdated(newEntry, oldEntry) {
  return call('timemachine', 'markUpdated', {
    newEntry: newEntry,
    oldEntry: oldEntry
  });
}

function makeUnique(entry) {
  var newEntry = entry;
  newEntry.keyHash = App.Key.Hash;
  newEntry.timestamp = Date.now();
  return newEntry;
}

// Exposed functions

function postCreate(input) {
  var postEntry = makeUnique(input.postEntry);
  var postHash = commit("post", postEntry);
  for(var i = 0; i < input.tags.length; i++) {
    var tag = input.tags[i];
    var anchorHash = anchor("tag", tag || '');
    var tagLinkHash = commit("tagLink", {
      Links: [
        {
          Base: anchorHash,
          Link: postHash,
          Tag: 'post'
        }
      ]
    });
    var tagLinkHash = commit("postLink", {
      Links: [
        {
          Base: postHash,
          Link: anchorHash,
          Tag: 'tag'
        }
      ]
    });
    var defaultTagLinkHash = commit("postLink", {
      Links: [
        {
          Base: postHash,
          Link: anchorHash,
          Tag: 'defaultTag'
        }
      ]
    });
  }
  var userLinkHash = commit("userLink", {
    Links: [
      {
        Base: App.Key.Hash,
        Link: postHash,
        Tag: 'post'
      }
    ]
  });
  return postHash;
}

function postRead(postHash) {
  var post = get(postHash);
  return post;
}

function postUpdate(params) {
  var replaces = params.replaces;
  var newEntry = makeUnique(params.newEntry);
  var postHash = update("post", newEntry, replaces);
  markUpdated(postHash, replaces);
  return postHash;
}

function postDelete(postHash) {
  var result = remove(postHash, "deleted");
  return result;
}

function search(query) {
  function objectEquate(a, b) {
    return JSON.stringify(a) == JSON.stringify(b);
  }

  function has(arr, obj) {
    for (var i = 0; i < arr.length; i++) {
      if (objectEquate(arr[i], obj)) {
        return true;
      }
    }
    return false;
  }

  // Actual search function that returns arrays
  function searchInternal(query) {
    var r = [];
    switch (query.type) {
      case "and":
        var vals = [];
        for (var i = 0; i < query.values.length; i++) {
          vals.push(searchInternal(query.values[i]));
        }

        if (vals[0]) {
          for (var i = 0; i < vals[0].length; i++) {
            // if it isn't in all vals, break and don't add
            var add = true;
            for (var k = 1; k < vals.length; k++) {
              if (!has(vals[k], vals[0][i])) {
                // not in val[v]
                add = false;
                break;
              }
            }

            if (add) {
              r.push(vals[0][i]);
            }
          }
        }
        break;
      case "or":
        for (var i = 0; i < query.values.length; i++) {
          r = r.concat(searchInternal(query.values[i]));
        }
        break;
      case "xor":
        // The generalization of the xor operation
        // to multiple inputs is uniqueness
        var vals = [];
        for (var i = 0; i < query.values.length; i++) {
          vals.push(searchInternal(query.values[i]));
        }

        for (var i = 0; i < vals.length; i++) {
          for (var k = 0; k < vals[i].length; k++) {
            var add = true;
            for (var v = 0; v < vals.length; v++) {
              if ((v != i) && has(vals[v], vals[i][k])) {
                // Not unique
                add = false;
                break;
              }
            }
            
            if (add) {
              r.push(vals[i][k]);
            }
          }
        }
        break;
      case "not":
        // The generalization of the not operation to multiple inputs
        // is to subtract all inputs from first input
        // So 5 ! 2 ! 3
        // Would be 5 without 2 nor 3
        var first = query.values[0];
        if (first) {
          var resultFirst = searchInternal(first);
          
          var remove = [];
          for (var i = 1; i < query.values.length; i++) {
            remove = remove.concat(searchInternal(query.values[i]));
          }

          for (var i = 0; i < resultFirst.length; i++) {
            if (!has(remove, resultFirst[i])) {
              r.push(resultFirst[i]);
            }
          }
        }
        break;
      case "exactly":
        var tag = query.values + ""; // cast to string
        var anc = anchor("tag", tag);
        r = getLinks(anc, "post", { Load: true });
        break;
    }

    // Remove duplicates

    var unduplicated = [];
    for (var i = 0; i < r.length; i++) {
      if (!has(unduplicated, r[i])) {
        unduplicated.push(r[i]);
      }
    }

    return unduplicated;
  }

  return searchInternal(query);
}

function fromUser(keyHash, statusMask) {
  return JSON.stringify(getLinks(keyHash, 'post', { Load: true, StatusMask: statusMask || HC.Status.Live }));
}

function crosspost(input) {
  for(var i = 0; i < input.to.length; i++) {
    var tag = input.to[i];
    var anchorHash = anchor("tag", tag);
    var tagLinkHash = commit("tagLink", {
      Links: [
        {
          Base: anchorHash,
          Link: input.from,
          Tag: 'post'
        }
      ]
    });
    var userLinkHash = commit("userLink", {
      Links: [
        {
          Base: App.Key.Hash,
          Link: input.from,
          Tag: 'post'
        }
      ]
    });
    var tagLinkHash = commit("postLink", {
      Links: [
        {
          Base: input.from,
          Link: tag,
          Tag: 'tag'
        }
      ]
    });
  }
}

function tagArray(links) {
  var r = [];
  for (var i = 0; i < links.length; i++) {
    r[i] = parseInt(links[i].Entry.anchorText);
  }
  return r;
}

function tags(postHash) {
  return JSON.stringify(
    tagArray(
      getLinks(postHash, "tag", { Load: true })
    )
  );
}

function defaultTags(postHash) {
  return JSON.stringify(
    tagArray(
      getLinks(postHash, "defaultTag", { Load: true })
    )
  );
}


// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis() {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

function validate(entryType, entry, header, pkg, sources) {
  switch (entryType) {
    case "post":
      return entry.keyHash == sources[0];
    case "postLink":
      for (var i = 0; i < entry.Links.length; i++) {
        var link = entry.Links[i];
        // Base must be post
        if (get(link.Base, { GetMask: HC.GetMask.EntryType }) != "post") {
          return false;
        }
        // Link must be tag
        if (get(link.Link, { GetMask: HC.GetMask.EntryType }) != "anchor") {
          return false;
        }
      }
      return true;
    case "tagLink":
      for (var i = 0; i < entry.Links.length; i++) {
        var link = entry.Links[i];
        // Base must be tag
        if (get(link.Base, { GetMask: HC.GetMask.EntryType }) != "anchor") {
          return false;
        }
        // Link must be post
        if (get(link.Link, { GetMask: HC.GetMask.EntryType }) != "post") {
          return false;
        }
      }
      return true;
    case "userLink":
      for (var i = 0; i < entry.Links.length; i++) {
        var link = entry.Links[i];
        // Link must be post
        if (get(link.Link, { GetMask: HC.GetMask.EntryType }) != "post") {
          return false;
        }
        // Source must be base
        // Implies base is key hash
        if (sources[0] != link.Base) {
          return false;
        }
      }
      return true;
  }
  // Invalid entry name
  return false;
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit(entryName, entry, header, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }

  // Validation special to validateCommit
  // switch (entryName) {
  //   case "post":
  //     return true;
  // }
  
  return true;
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut(entryName, entry, header, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }
  
  // // Validation special to validatePut
  // switch (entryName) {
  //   case "post":
  //     return true;
  // }

  return true;
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod(entryName, entry, header, replaces, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }

  // Validation special to validateMod
  switch (entryName) {
    case "post":
      return get(replaces, { GetMask: HC.GetMask.Sources })[0] == sources[0];
    case "tagLink":
    case "userLink":
    case "postLink":
      return false;
  }

  return true;
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel(entryName, hash, pkg, sources) {
  switch (entryName) {
    case "post":
      return get(hash, { GetMask: HC.GetMask.Sources })[0] == sources[0];
    case "tagLink":
    case "userLink":
    case "postLink":
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink(entryName, baseHash, links, pkg, sources) {
  // These links will have to be validated by validatePut to get here

  switch (entryName) {
    case "post":
      // Not a link, don't validate
      return false;
    case "tagLink":
    case "userLink":
      return true;
    case "postLink":
      switch (links[0].Tag) {
        case "defaultTag":
          return sources[0] == get(links[0].Base, { GetMask: HC.GetMask.Sources });
        case "tag":
          return true;
        default:
          return false;
      }
  }

  return true;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg(entryName) {
  return null;
}