'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

// Helper timemachine functions

function markUpdated(newEntry, oldEntry) {
  return call('timemachine', 'markUpdated', {
    newEntry: newEntry,
    oldEntry: oldEntry
  });
}

// Exposed functions

function vote(input) {
  var voteLink = myVote(input.targetHash);
  var voteEntry = input.voteEntry;
  voteEntry.keyHash = App.Key.Hash;
  voteEntry.timestamp = Date.now();
  if (!voteEntry.inTermsOf) {
    var targetPost = get(input.targetHash);
    if (targetPost) {
      var defaultTagLinks = getLinks(input.targetHash, "defaultTag", { Load: true });
      var defaultTags = [];
      for (var i = 0; i < defaultTagLinks.length; i++) {
        defaultTags[i] = parseInt(defaultTagLinks[i].Entry.anchorText);
      }
      voteEntry.inTermsOf = defaultTags;
    } else {
      // Not voting on anything
      voteEntry.inTermsOf = [];
    }
  }
  if(voteLink) {
    // if voted on it before, update vote entry
    var newVote = update("vote", voteEntry, makeHash("vote", voteLink.Entry));
    markUpdated(newVote, makeHash("vote", voteLink.Entry));
    return newVote;
  } else {
    // if not voted on it before, just create a vote & link it
    var newVote = commit("vote", voteEntry);
    var newVoteLink = commit("voteLink", { Links: [{ Base: input.targetHash, Link: newVote, Tag: "vote" }] });
    return newVote;
  }
}

function fromHash(hash, statusMask) {
  var it = JSON.stringify(
    getLinks(hash, "vote", { Load: true, StatusMask: statusMask || HC.Status.Live })
  );
  return it;
}

function myVote(hash) {
  var links = getLinks(hash, "vote", { Load: true });

  for(var i = 0; i < links.length; i++) {
    var link = links[i];
    if(link.Source == App.Key.Hash) {
      return link;
    }
  }

  return null;
}

// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis() {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit(entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return entry.fraction >= 0 && entry.fraction <= 1 && entry.keyHash == sources[0];
    case "voteLink":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      var links = getLinks(entry.Links[0].Base, "vote", { Load: true });
      var filteredLinks = [];
      for(var i = 0; i < links.length; i++) {
        if(links[i].Source == App.Key.Hash) {
          filteredLinks.push(links[i]);
        }
      }
      return (get(entry.Links[0].Base) != HC.HashNotFound) 
        && (filteredLinks.length == 0);
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut(entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "voteLink":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod(entryName, entry, header, replaces, pkg, sources) {
  switch (entryName) {
    case "vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!

      // Prevents modification loops (entry a updated to b, b updated to a)
      if(makeHash("vote", get(makeHash("vote", entry))) == makeHash("vote", get(replaces))) {
        throw "Modification Loop";
      }

      return (get(replaces, { GetMask: HC.GetMask.Sources })[0] == sources[0]);
    case "voteLink":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel(entryName, hash, pkg, sources) {
  switch (entryName) {
    case "vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    case "voteLink":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink(entryName, baseHash, links, pkg, sources) {
  switch (entryName) {
    case "vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    case "voteLink":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg(entryName) {
  return null;
}